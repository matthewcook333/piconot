Team 6 - Matt Cook, Chloe Calvarin


9/23
- We defined an outline of our ‘ideal’ syntax over the weekend. Instead of 
listing a rule for every possible state and surroundings, we want to be able to
say, for a ‘state,’ here are the directions we wish to go in, in priority 
order. If the first is blocked by a wall, then try the second direction, if 
that’s blocked by a wall, try the third, etc.
- Instead of keeping to the basic cardinal directions, we prefer using ‘Front, 
Right, Back, Left,’ as our direction to travel in, which means that the ‘state’ 
variable will actually only store the direction we’re facing, in cardinal 
terms, NESW.
- We also played around with possible sillier ways to word our commands, but 
for now we will work on implementing something that ideally looks like:

	FacingDirection -> Direction1, Direction2, Direction3, Direction4
	N -> Front, Left, Right, Back

	
- For now, we are thinking of implementing it with -> being a method on the 
facing direction object, (we’re calling this a “CardinalState”) that takes in a 
list of 4relative directions. This forces us to have parenthesis, so it’s, say 
a Delta 3 on syntax change.

	N ->(F, L, R, B)

- We discussed different ways to implement this. Either we have a hard-coded 
rule-generator that takes each facing direction and translates the priority 
list of relative directions into standard picot rules, or we map the pairs of 
facing and relative directions to a move direction, and then go from there. The 
later would require less code, but it might be more error-prone. This has not 
yet become a change in the syntax.

- Done for now, today was mostly discussion and figuring out the API.

9/27
- We decided to go with the mapping of cardinal and relative direction to a 
MoveDirection. This way, we can just have a general translation of our 
language into the Rules with MoveDirection so there won't be a lot of 
duplicated code.
- We had each state with a name of a number, but now changed it to the names of 
CardinalStates as that makes more sense as ultimately there are only 4 states, 
one for each Cardinal direction.
- After this, we decided to test what we currently have with the Empty.scala 
file and got it to work after fixing some simple syntax and type issues 
(we were trying to pass in a list of Directions rather than repeated parameters
for our "->" method).
- We got it to work for the empty room! It took a little reasoning to figure out
how we could basically sweep over whole room (err... we swear it is good syntax 
design!...) but figured out that if we are sweeping right, the moment we need to
go west (as in hit the corner), we should go ALL the way west, and repeat the 
sweeping.
- We now want to figure out a way to get rid of the necessity of calling flatten
as we have a list of list of rules, and cannot quite figure out how to make a 
def (called like "begin" or something) that would take in the list of list of 
rules and simply flatten them. But we are done here for the day!
